## Binary Tree
---
<details>
  <summary>BinaryTree Code</summary>

```python
class BinaryTree:
    def __init__(self, key):
        self.key = key
        self.leftChild = None
        self.rightChild = None
    
    def __str__(self):
        return str(self.key)

    def setLeftChild(self, tree):
        assert self.hasLeftChild() is False
        self.leftChild = tree

    def setRightChild(self, tree):
        assert self.hasRightChild() is False
        self.rightChild = tree
        
    def getLeftChild(self):
        assert self.hasLeftChild()
        return self.leftChild
    
    def getRightChild(self):
        assert self.hasRightChild()
        return self.rightChild
    
    def hasLeftChild(self):
        return True if self.leftChild is not None else False
    
    def hasRightChild(self):
        return True if self.rightChild is not None else False

    def preorder(self):
        print(self)
        if self.hasLeftChild():
            self.getLeftChild().preorder()
        if self.hasRightChild():
            self.getRightChild().preorder()
    
    def inorder(self):
        if self.hasLeftChild():   
            self.getLeftChild().inorder()
        print(self)
        if self.hasRightChild():
            self.getRightChild().inorder()
        
    def postorder(self):
        if self.hasLeftChild():
            self.getLeftChild.postorder()
        if self.hasRightChild():
            self.getRightChild().postorder()
        print(self)
```
</details>

<details>
  <summary>BinaryTree Code Example</summary>

![Example](https://github.com/wilison1992/Algorithm-Practice/blob/master/pictures/Tree_exampleA.png?raw=true)  

Create Tree example A:  
When creating a tree, all nodes and leaves should be __Node__

```python
T1 = BinaryTree(7)
T1.setLeftChild(BinaryTree(8))
T1.getLeftChild().setLeftChild(BinaryTree(12))
T1.getLeftChild().getLeftChild().setLeftChild(BinaryTree(5))
T1.getLeftChild().getLeftChild().setRightChild(BinaryTree(10))
T1.setLeftChild().setRightChild(9ï¼‰

T1.setRightChild(7)
T1.getRightChild().setLeftChild(5)
T1.getRightChild().setRightChild(6)
```
![Example](https://github.com/wilison1992/Algorithm-Practice/blob/master/pictures/Tree_exampleB.png?raw=true)  
Create Tree example B:  

```python
root = BinaryTree(7)
root.setLeftChild(BinaryTree(8))
root.getLeftChild().setLeftChild(BinaryTree(12))
root.getLeftChild().getLeftChild().setLeftChild(BinaryTree(5))
root.getLeftChild().getLeftChild().setRightChild(BinaryTree(10))

root.setRightChild(BinaryTree(7))
root.getRightChild().setLeftChild(BinaryTree(5))
root.getRightChild().getLeftChild().setLeftChild(BinaryTree(5))
root.getRightChild().setRightChild(BinaryTree(6))
root.getRightChild().getRightChild().setLeftChild(BinaryTree(10))
```
</details>

Tree_example A:  
![Example](https://github.com/wilison1992/Algorithm-Practice/blob/master/pictures/Tree_exampleA.png?raw=true)  

Tree_example B:  
![Example](https://github.com/wilison1992/Algorithm-Practice/blob/master/pictures/Tree_exampleB.png?raw=true)  

<details>
    <summary>Preorder</summary>

root --> count all left --> then right  
Tree_exampleA: [7, 8, 12, 5, 10, 9, 7, 5, 6]  
Tree_exampleB: [7, 8, 12, 5, 10, 7, 5, 5, 6, 10]  
```python
def preorder(tree):
    print(tree)
    if tree.hasLeftChild():
        preorder(tree.getLeftChild())
    if tree.hasRightChild():
        preorder(tree.getRightChild())
```

</details>

<details>
    <summary>Inorder</summary> 

bottom left -->  node --> bottom right  
Tree_exampleA: [5, 12, 10, 9, 8, 7, 5, 7 ,6]   
Tree_exampleB: [5, 12, 10, 8, 7, 5, 5, 7, 10, 6]
```python   
def inorder(tree):
    if tree.hasLeftChild():
        inorder(tree.getLeftChild())
    print(tree)
    if tree.hasRightChild():
        inorder(tree.getRightChild())
```
</details>

<details>
    <summary>Postorder</summary>

bottom left --> bottom right --> node   
Tree_exampleA: [5, 10, 12, 9, 8, 5, 6, 7, 7]   
Tree_exampleB: [5, 10, 12, 8, 5, 5, 10, 5, 6, 7, 7]   
```python
def postorder(tree):
    if tree.hasLeftChild():
        postorder(tree.getLeftChild())
    if tree.hasRightChild():
        postorder(tree.getRightChild())
    print(tree)
```

</details>

<details>
    <summary>BFS</summary>

![BFS](https://github.com/wilison1992/Algorithm-Practice/blob/master/pictures/BFS.png?raw=true)  
  
```python 
### Tree is an object of Binary Trees
from collections import deque
def iterativeBFS(tree):
    queue = deque()
    queue.appendleft(tree)
    while len(queue) != 0:
        node = queue.pop() # pop from right
        print(node)
        if node.hasLeftChild():  ### Left First
            queue.appendleft(node.getLeftChild())
        if node.hasRightChild():
            queue.appendleft(node.getRightChild())
```
</details>

<details>
    <summary>DFS</summary> 

![DFS](https://github.com/wilison1992/Algorithm-Practice/blob/master/pictures/DFS.png?raw=true)    

```python
### Tree is an object of Binary Trees
from collections import deque
def iterativeBFS(tree):
    queue = deque()
    queue.appendleft(tree)
    while len(queue) != 0:
        node = queue.popleft()  # pop from left
        print(node)
        if node.hasRightChild():  ### Right First
            queue.appendleft(node.getRightChild())

        if node.hasLeftChild():
            queue.appendleft(node.getLeftChild())
```
</details>

<details>
    <summary>Measure Height & Complexity<summary>

```python
    def measureHeight(tree):
        if not tree.hasLeftChild() and not tree.hasRightChild():
            return 0
        else:
            left, right = 0, 0
            if tree.hasLeftChild():
                left = measureHeight(tree.getLeftChild())
            if tree.hasRightChild():
                right = measureHeight(tree.getRightChild())
            return max(left, right) + 1
```
Time Complexity: O(n)  
Space Compexity: BestCase: O(logn) Balanced   
WorseCase: O(n)  only one node 
</details>

<details>
    <summary>Measure Height & Complexity<summary>

The depth of a node is the number of edges from the tree's root node to the node. Given a value v, write a recursive function that returns the minimum depth of a node for which self.key == v. Return None if the value is not in the tree.  

```python
    def final(tree):
        if not tree.hasLeftChild() and not tree.hasRightChild():
            return 0
        else:
            left, right = 0, 0
            if tree.hasLeftChild():
                left = measureHeight(tree.getLeftChild())
            if tree.hasRightChild():
                right = measureHeight(tree.getRightChild())
            return max(left, right) + 1
```
Time Complexity: O(n)  
Space Compexity: BestCase: O(logn) Balanced   
WorseCase: O(n)  only one node 
</details>
