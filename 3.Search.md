## Search Algorithm
--
<details>
    <summary>Binary Search</summary>
A binary search of an ordered list is ğ‘‚(logğ‘›) in the worst case.   
Binary Search always compare to next one   
Suppose you have the following sorted list [3, 5, 6, 8, 11, 12, 14, 15, 17, 18] and are using the recursive binary search algorithm. Which group of numbers correctly shows the sequence of comparisons used to search for the key 16?  
12, 17, 15
</details>

<details>
    <summary>sequential search</summary>
A sequential search is ğ‘‚(ğ‘›) for ordered and unordered lists.    
</details>


### Hash Tables
Hash tables can provide constant time searching.  

<details>
    <summary>Collision Resolution and Linear</summary>

When two items hash to the same slot, we must have a systematic method for placing the second item in the hash table. This process is called __collision resolution__ .  

<details>
    <summary>Linear</summary>
    
![Example](https://github.com/wilison1992/Algorithm-Practice/blob/master/pictures/Linear_hash.png?raw=true)
</details>

</details>






<details>
    <summary>Deletion in a Hash table</summary>

When we delete hash table, if doing hash searching, we have to add "-1" into slot not just delete values in slot
</details>

<details>
    <summary>Prove of probed slot</summary>
we can prove that this will always be the case: suppose that  ğ‘–âˆˆ{1,â€¦,ğ‘›} , and let  ğ‘–2â‰¡ğ‘(modğ‘›)  (in our example,  ğ‘=3 ). Then
(ğ‘–+ğ‘˜ğ‘›)2=ğ‘–2+2ğ‘–ğ‘˜ğ‘›+(ğ‘˜ğ‘›)2â‰¡ğ‘–2(modğ‘›)â‰¡ğ‘(modğ‘›) 
since  2ğ‘–ğ‘˜ğ‘›  and  (ğ‘˜ğ‘›)2  are both divisible by  ğ‘› . So it is pointless to iterate past  ğ‘› , as we will keep probing the same slots!  

Can we now prove that not all slots will be probed?  

Yes! Just observe that for  ğ‘–âˆˆ{1,â€¦,ğ‘›}  we have:  

* i^2â‰¡ğ‘(modğ‘›) 
* (ğ‘›âˆ’ğ‘–)2=ğ‘›2âˆ’2ğ‘–ğ‘›+ğ‘–2â‰¡ğ‘(modğ‘›)
This means that if we iterate over the first half of the range  {1,â€¦,ğ‘›} , we will probe the same slots as if we iterate over the second half  
```python
n=97 #don't put 2
halves = [range(1, (n+1)//2), range((n+1)//2, n)]
skips = []
for half in halves:
    slots = set()
    for i in half:
        slots.add((i**2)%n)
    print(slots)
    skips.append(slots)
assert skips[0]==skips[1]
```
</details>